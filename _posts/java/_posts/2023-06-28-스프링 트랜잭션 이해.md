---
layout: post
date: 2023-06-28 13:45:22+0900
title: 스프링 트랜잭션 이해
categories: java
tag: [transaction, spring]
---

# 스프링 트랜잭션 이해

- 선수지식 : [트랜잭션 적용](/java/2023-06-11-트랜잭션 적용)


## 프록시 도입전

트랜잭션을 처리하기 위한 프록시를 도입하기 전에는 서비스의 로직에서 트랜잭션을 직접 시작했다.

| ![사진]({{"/assets/img/java/23-06-28/프록시 도입 전.png" | relative_url}}) |
|:--------------------------------------------------------------------:|
|                         프록시 도입 전                          |

```java
public class TransactionProxy {
    private MemberService target;
    public void logic() {
        //트랜잭션 시작
        TransactionStatus status = transactionManager.getTransaction(..);
        try {
            //실제 대상 호출 
            target.logic();
            transactionManager.commit(status); //성공시 커밋 
        } catch (Exception e) {
            transactionManager.rollback(status); //실패시 롤백
            throw new IllegalStateException(e);
          }
    }
}
```

- 프록시 도입 전: 서비스에 비즈니스 로직과 트랜잭션 처리 로직이 함께 섞여있다.


## 프록시 도입 후 

트랜잭션을 처리하기 위한 프록시를 적용하면 트랜잭션을 처리하는 객체와 비즈니스 로직을 처리하는 서비스 객체를 명확하게 분리할 수 있다.

| ![사진]({{"/assets/img/java/23-06-28/프록시 도입 후.png" | relative_url}}) |
|:--------------------------------------------------------------------:|
|                         프록시 도입 후                          |


```java
public class Service {
    public void logic() {
        //트랜잭션 관련 코드 제거, 순수 비즈니스 로직만 남음
        bizLogic(fromId, toId, money);
    }
}
```

- 프록시 도입 후: 트랜잭션 프록시가 트랜잭션 처리 로직을 모두 가져간다. 그리고 트랜잭션을 시작한 후에 실제 서비스를 대신 호출한다. 트랜잭션 프록시 덕분에 서비스 계층에는 순수한 비즈니즈 로직만 남길 수 있다.


## 프록시 도입 후 전체 과정

| ![사진]({{"/assets/img/java/23-06-28/프록시 도입 후 전체 과정.png" | relative_url}}) |
|:--------------------------------------------------------------------:|
|                         프록시 도입 후 전체 과정                          |

- 트랜잭션은 커넥션에 con.setAutocommit(false) 를 지정하면서 시작한다. 
- 같은 트랜잭션을 유지하려면 같은 데이터베이스 커넥션을 사용해야 한다.
- 이것을 위해 스프링 내부에서는 트랜잭션 동기화 매니저가 사용된다.
- JdbcTemplate 을 포함한 대부분의 데이터 접근 기술들은 트랜잭션을 유지하기 위해 내부에서 트랜잭션 동기화 매니저를 통해 리소스(커넥션)를 동기화 한다.


## 스프링 컨테이너에 트랜잭션 프록시 등록

| ![사진]({{"/assets/img/java/23-06-28/스프링 컨테이너에 트랜잭션 프록시 등록.png" | relative_url}}) |
|:--------------------------------------------------------------------:|
|                         스프링 컨테이너에 트랜잭션 프록시 등록                          |

- @Transactional 애노테이션이 특정 클래스나 메서드에 하나라도 있으면 있으면 트랜잭션 AOP는 프록시를 만들어서 스프링 컨테이너에 등록한다.
  그리고 실제 basicService 객체 대신에 프록시인 basicService$$CGLIB 를 스프링 빈에 등록한다.

- 그리고 프록시는 내부에 실제 basicService 를 참조하게 된다. 여기서 핵심은 실제 객체 대신에 프록시가 스프링 컨테이너에 등록되었다는 점이다. 
  클라이언트인 txBasicTest 는 스프링 컨테이너에 @Autowired BasicService basicService 로 의존관계 주입을 요청한다. 
  스프링 컨테이너에는 실제 객체 대신에 프록시가 스프링 빈으로 등록되어 있기 때문에 프록시를 주입한다.
  
- 프록시는 BasicService 를 상속해서 만들어지기 때문에 다형성을 활용할 수 있다.
  따라서 BasicService 대신에 프록시인 BasicService$$CGLIB 를 주입할 수 있다.

  
## 트랜잭션 프록시 동작 방식

| ![사진]({{"/assets/img/java/23-06-28/트랜잭션 프록시 동작 방식.png" | relative_url}}) |
|:--------------------------------------------------------------------:|
|                         트랜잭션 프록시 동작 방식                          |

- 클라이언트가 주입 받은 basicService$$CGLIB 는 트랜잭션을 적용하는 프록시이다

